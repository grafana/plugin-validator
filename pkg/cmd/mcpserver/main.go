package mcpserver

import (
	"context"
	"fmt"
	"log"

	"github.com/modelcontextprotocol/go-sdk/mcp"
)

type Input struct {
	PluginPath    string `json:"pluginPath" jsonschema:"required,description=The path to the plugin directory. This can be a local file path or a URL. If it's a URL, it must be a zip file."`
	SourceCodeUri string `json:"sourceCodeUri" jsonschema:"description=The URI of the source code. This can be a local file path (zip or folder) or a URL. If it's a URL, it must be a git repository or a zip file."`
}

type Output struct {
	Analysis string `json:"analysis" jsonschema:"description=The name of the analysis that was run."`
	Report   string `json:"report" jsonschema:"description=The report generated by comparing the source map with the source code."`
}

func ValidatePlugin(ctx context.Context, req *mcp.CallToolRequest, input Input) (*mcp.CallToolResult, Output, error) {
	return nil, Output{}, nil
}

func run() error {
	server := mcp.NewServer(&mcp.Implementation{Name: "plugin-validator", Version: "0.1.0"}, nil)
	mcp.AddTool(server, &mcp.Tool{
		Name:        "validate_plugin",
		Description: "Validates a Grafana plugin against publishing requirements. Checks metadata, security, structure, and best practices. Returns detailed errors and warnings with actionable fix suggestions.",
	}, ValidatePlugin)
	if err := server.Run(context.Background(), &mcp.StdioTransport{}); err != nil {
		return fmt.Errorf("failed to run server: %w", err)
	}
	return nil
}

func main() {
	if err := run(); err != nil {
		log.Fatalf("failed to run: %v", err)
	}
}
